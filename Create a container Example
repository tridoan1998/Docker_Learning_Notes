docker image pull <repository>:<tag>    << This will pull the image 
cd pswed                << Go to the directory that store the repository we just pull from the web
ls                      << check to see for the Dockerfile 
cat Dockerfile          << check for their components before build 
docker image build -p <image ID or name> <tag>    << build our image using the Dockerfile, -p make it run in the background 
docker image ls -a    <<check to see what image are running
docker tag <existing-image> <hub-user>/<repo-name>[:<tag>]    << create a new tag for the image to get ready to push it to the Docker Hub 
docker push <hub-user>/<repo-name>:<tag>                 << push the newly created image to Docker Hub for storage and sharing
docker container run -p <image ID>:<tag> << run container with the image ID in the background 
docker stop <image ID>
docker rm <image ID>
docker container run -d --name <name> \ -p 80:8080 \ <image name>:<tag> << run the app
#next is to use docker compose to manage multople microservices aka many containers all together
#docker compose use the YAML file (docker-compose.yml) => this file is the glue that sticks all the application microservises together, it describes how Docker should build and deploy the app. 
docker-compose --version 
#docker compose should have Dockerfile used to build the image, and the docker-compose YAML file, plus the app.py for the application code, and the requirements.txt that list te Python packages required for the app.
docker-compose up &  << this will run the app.py with Flask web framework, use Dockerfile to build image, use docker-compose to glue all applications files together and use requirenment.txt to run required libraries
docker container ls << check the port for web browser 
docker-compose down << take down

docker-compose run $ << make sure we have the docker-compose.yml file ready which contains version, services, volumn => a ton of them
docker-compose down  << take down the compose 

#next we will go over how to create an image of Apache and run a container, deploy it to the web
git clone httpd .
mkdir apache_demo 
cd apache_demo
vi Dockerfile 
#cope the requirement in the Apache website to create the Dockerfile for Apache 
docker image build -t apache_demo /bin/bash .
docker container run -d apache_demo - p 8080:8080 /bin/bash
docker ps  << show all the process are running, which also show the port they are running on
docker swarm init << create swarm and set the node as manager
docker swarm join-token worker1 
docker swarm join-token worker2
docker swarm join-token manager2

docker network create my-net  << create a network bridge for single host 
docker container create --name my-nginx --network my-net --publish 8080:80 my-nginx:latest << create container 
docket network connect my-net my-nginx << connect bridge network with the container 

#practice docke commands:
docker run -it devopsdockeruh/pull_exercise .  << run the container and connect the container to the terminal, build it from the image in the current directory, using the name ID given 
#Dockerfile is basically a file that contains everything it needed to build an image for the container. The format is: FROM <image used>, RUN <install the dependency>, WKDIR <the dicrectory the image will be build on>
#each of these instruction will stack up one on top of another to build an image. This is why our image will have many layers. 





